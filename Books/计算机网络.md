# 自顶向下之——计算机网络

计算机网络是前端工程师不可或缺的一项技能。这里涉及到OSI七层模型，TCP五层模型等。本小册借鉴与整理了图解计算机网络系列并针对前端工程师常见面试题进行了知识输出。

## OSI七层模型

概念：**开放式系统互联模型**（英语：Open System Interconnection Model，缩写：OSI；简称为OSI模型）是一种[概念模型](https://zh.wikipedia.org/wiki/概念模型)，由[国际标准化组织](https://zh.wikipedia.org/wiki/国际标准化组织)提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。

该模型将通信系统中的数据流划分为七个层，从跨通信介质传输位的物理实现到分布式应用程序数据的最高层表示。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。

![aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMjAxLzUvMF8xMzI1NzQ0NTk3V00zMi5naWY](https://gitee.com/krialy/images/raw/master/source/20210302163252.gif)



## TCP/IP分层管理

TCP/IP协议族按照层次分别分为这几个层次：应用层、传输层、网络层和数据链路层。

#### 为什么要对网络协议族分层？

它的思想就是可拓展与维护性强，如果我们想要替换某个协议，我们只需要修改与替换修改该协议对应的层次即可，修改成本低，且出现bug的概率也会显著降低。如果将所有协议封装成了一层次，如果需要替换其中一个协议，它的影响范围会很大，需要修改整个层次。

这就好比软件工程中的职责单一的原则。职责单一会让我们的软件拓展性更强，维护性更好。

#### 它与OSI七层模型的区别？

20世纪90年代，ISO开展了OSI这一国际标准协议的标准化进程，然而，OSI协议并没有得到普及，真正被广泛使用的是TCP/IP协议。OSI参考模型注重“通信协议必要的功能是什么”，而TCP/IP更强调“在计算机上实现协议应该开发哪种程序”；虽然OSI并未被得到普及，但是TCP/IP的各种协议其实也能对应到OSI参考模型当中，清楚这些协议分属于OSI的哪一层，就能对该协议的目的有所了解。下面是各个协议与OSI参考模型中各个分层之间的对应关系。

![image-20210302164642411](https://gitee.com/krialy/images/raw/master/source/20210302164643.png)

## 应用层协议之——什么是HTTP

HTTP又叫超文本传输协议，**协议**产生的最初原因就是为了解决传输的一致性，如果没有协议，客户端与服务端是无法交流的，这就好比两国人，如果没有语言这个协议，也是无法沟通的。

#### 为什么会有HTTPS？

首先我们看下HTTP的不足：

1. 通信使用明文，内容可能会抓取窃听。
2. 不验证通信方的身份，因此很有可能会被伪装。
3. 无法证明报文的正确性与完整性，内容很有可能会被修改。

![image-20210302155043402](https://gitee.com/krialy/images/raw/master/source/20210302155044.png)

现在，要如何解决这些问题呢？

**传统加密方案**：采用密钥的方式进行加密解密（共享密钥法）。

显然，这种方案在http加密中是不够有效的，因为在通信的时候需要把密钥传给需要发送的目标，然而发送的过程中，中途是很有可能出现密钥被第三方截取的可能。

**方案二**：使用HTTPS

HTTPS = HTTP + 加密+认证+完整性保护，因为HTTP本身是没有加密机制的，所以需要借助其他协议来进行加密。

HTTPS是身披了SSL外壳的HTTP，它并非是新的应用层协议，仅仅是协议的组合。

![image-20210302155014003](https://gitee.com/krialy/images/raw/master/source/20210302155015.png)

下面讲解SSL的加密方式（公开密钥加密方式）：

SSL使用了一种非对称的密钥：一包叫做密钥（private key），另外一把叫做公钥（public key）。

这里举个例子：小王、小明和小红三者进行通讯。

小王：一把自己的密钥；一把小明的公钥；一把小红的公钥

小明：一把自己的密钥；一把小王的公钥；一把小红的公钥；

小红：一把自己的密钥；一把小王的公钥；一把小明的公钥；

现在小王和小红通讯，小红发送了一条信息并且通过小王的公钥进行加密，小王收到后用自己的密钥解密即可。这里即使小红的信件被截取了，别人也无法解密，因为只能通过小王的密钥才可以解密。除非小王自己弄丢了自己的密钥。（如果小王想发送讯息给小红，使用小红的公钥对讯息加密然后发送给小红即可）

这里还存在一个问题，如果小红的公钥并不是小王的公钥该怎么办？如果小明偷偷把自己的公钥和小红的公钥交换了，那么小明就能伪造小王来与小红通讯了！

那么该如何解决？

使用数字证书认证机构（CA）和其他相关机关颁发的公开密钥技术。CA机构能够保证小红拿到的公钥是小王的公钥。

![image-20210302165140542](https://gitee.com/krialy/images/raw/master/source/20210302165142.png)

#### HTTP中的缓存机制

#### HTTP的发展历程

- HTTP1.0
- HTTP1.1
- HTTP2.0

在互联网发展的早期，浏览器任务仅仅是展示一些纯文本和零星的图片，因此http1.0足够使用。但是随着互联网的发展，网页变得越来越复杂，原有的1.0协议太慢，我们不得不对1.0进行优化。由于http是基于tcp的，所以优化思路很多都是基于tcp协议本身的特性。

#### HTTP1.0与HTTP1.1的主要区别

1. 增加了新的状态码：HTTP1.1新增了一些状态码，用于更好地与服务端交流。
2. 缓存处理：Http1.0主要使用Expires和If-modified-since字段来控制缓存，然而原有字段存在一些缺陷，因此1.1增加了Etag、Cache-Controll等字段来更好地进行缓存处理
3. 长连接：HTTP1.1支持长连接，长连接使得一个TCP连接上能够传输多个HTTP请求和响应，减少了不断建立与断开TCP连接引来额外不必要的资源消耗。它对应于请求头中的Connection:keep-alive![image-20210303200832180](../../../../Library/Application%20Support/typora-user-images/image-20210303200832180.png)

## HTTP1.x仍然存在的问题

1. header携带的内容过大，而且很多时候我们每次请求的header是基本一样的，请求数据的时候会增加额外成本。
2. HTTP1.1虽然支持长连接，但是仍然无法解决线头阻塞问题。除此之外，长连接在某些时候会产生不必要的资源浪费，例如我们只需要传输单文件。

## HTTP2.0新特性

1. 新的二进制
2. 多路复用
3. header压缩
4. 服务端推送（server push）

## 会话层协议之——DNS

#### 为什么会出现DNS协议？

我们都知道IP地址是一串无任何意义的代码，非常不便与记忆，而且很多时候IP地址都非常长，这更加导致了IP地址难于记忆。

为了解决这个难题，可以使用主机识别码，也就是hosts文件来建立相应的映射，hosts文件由一个互联网信息中心管理派发，从而不用每次都输入冗长的IP地址了。但是，它存在一个问题，如果互联网中心的hosts文件出现了变更，需要其他计算机同步hosts文件网络才能正常访问，否则会存在映射到不相干的IP地址的情况。

![image-20210302171205720](https://gitee.com/krialy/images/raw/master/source/20210302171207.png)

#### 因此，DNS诞生了

DNS维护了一个用来表示组织内部主机名和IP地址对应关系的数据库。当用户输入主机名（域名）时，DNS会自动检索那个注册了主机名和IP地址的数据库，并迅速定位对应的IP地址。并且如果主机名和IP的映射有变更时，我们也不需要让所有个体计算机或者机构报告了，只需要在内部进行处理即可。

#### DNS的查询机制

![image-20210302203703341](https://gitee.com/krialy/images/raw/master/source/20210302203705.png)

DNS解析流程：

1. 浏览器DNS缓存
2. 本地hosts文件
3. 本地域名服务器缓存
4. 递归查询本地域名服务器
5. 本地域名服务器迭代查询根域名服务器
6. 最后根域名服务器返回结果给本地域名服务器
7. 本地域名服务器再将结果返回给客户端并设置刚刚访问的缓存

#### CDN是什么？

内容交付网络（CDN）是指一组在地理上分散的服务器，它们协同工作以提供互联网内容的快速交付。

CDN允许快速转移加载互联网内容所需的资产，包括HTML页面、javascript 文件、样式表、图像和视频。 CDN服务的受欢迎程度持续增长。如今，大多数网页流量都通过CDN提供服务，包括来自Facebook、奈飞和亚马逊等主要网站的流量。

CDN的好处：

1. 缩短网站加载时间。通过使用附近的CDN服务器，将内容分发到访问者附近，因而访问者能够更快地获取资源。
2. 减少带宽成本

**CDN如何工作：**

CDN的核心是连接在一起的服务器网络，其目标是尽可能快速、低价、可靠和安全地交付内容。为了提高速度和连接性，CDN会将服务器放置在不同网络之间的交换点。

![image-20210302205404605](https://gitee.com/krialy/images/raw/master/source/20210302205406.png)

这些互联网交换点是不同互联网提供商连接的主要位置，以便彼此提供对来自其不同网络的流量的访问。通过连接到这些高速且高度互连的位置，CDN 提供商可以减少高速数据传递中的成本和传输时间。

## 传输层协议之——TCP与UDP

#### 什么是TCP？

TCP是一种面向连接的、可靠的流协议。流就是指不间断的数据结构。举个例子，如果我们要把一个空碗装满水，我们可以一次倒入，也可以分批次倒入。但是如果我们要把一个苹果完整地放进另外一个碗中，我们只能选择一次放入。接水的过程就好比TCP传输数据一般，放苹果的过程就好比UDP传输过程一般。

TCP为了提供可靠性传输，实行“顺序控制”和“重发机制”。除此之外，为了提高性能，TCP还具有**流量控制**、**拥塞控制**等功能。

#### TCP是如何实现可靠的？

这就好比我们在聊天软件中聊天，当你发送一条消息“在吗？”，对方需要做出应答你才能知道对方是否有收到你的消息（虽然发在吗很直男哈哈）。TCP也是如此，TCP通过标志信息（ACK）来确认对方是否收到了消息。如果没有收到ACK那么很有可能信息出现了丢失。

![image-20210303101250173](https://gitee.com/krialy/images/raw/master/source/20210303101252.png)

如果出现了信息丢失，发送端还会**重新发送信息**，由此保证可靠性。

![image-20210303102004905](https://gitee.com/krialy/images/raw/master/source/20210303102006.png)

##### 如何确认重新发送丢失信息包的时机？



发送端有时候未接收到接受端的ACK应答的情况有时候是因为在接受端发送ACK之后，在传输ACK的途中丢包了，所以发送端又会**重新发送信息**。这对于接受端来说简直就是灾难，因为会接受到重复的信息。

![image-20210303102642967](https://gitee.com/krialy/images/raw/master/source/20210303102645.png)

为了为上层应用提供可靠的信息，接受端必须放弃重复的数据包。为此，就必须引入一种能够判断是否收到数据以及是否接受数据的机制。

因此，TCP引入了序列号的概念。序列号是按顺序给发送数据的每一个字节都标上号码编号。接受端查询查询接受数据TCP首部中的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。因此，保证可靠性传输。

![image-20210303103753157](https://gitee.com/krialy/images/raw/master/source/20210303103755.png)



#### TCP是如何建立连接的？

三次握手与四次挥手：

![image-20210303104932129](https://gitee.com/krialy/images/raw/master/source/20210303104933.png)

#### TCP是以段为单位发送数据

TCP在建立连接的同时也确定了发送数据包的单位大小，我们将它称为“最大消息长度”（MSS: Maximum Segment Size）。在三次握手的时候由发送端和接受端协调（取两者直接较小者可以接收的长度）来确定数据包的单位小。

![image-20210303111757266](https://gitee.com/krialy/images/raw/master/source/20210303111758.png)

#### TCP中的滑动窗口机制

TCP每次以一个段为单位发送信息，每发送一个段都要进行一次确认应答。这么做会带来网络性能的问题，因为每次每个段都需要等待应答之后才能发送下个端，等待的时间越长，网络性能自然就更差。

为此，就引入了滑动窗口的机制，发送端每次发送完一个单位的数据后不需要立刻等待接受端返回应答，只需要保证在滑动窗口设定好的大小内收到确认应答即可。收到应答之后相应地进行窗口滑动，从而适应后续的数据发送。

![image-20210303113047581](https://gitee.com/krialy/images/raw/master/source/20210303113049.png)

#### TCP中的流量控制

首先靓仔发问，为什么TCP需要做流量控制？

现在存在这么一个情况，我们知道发送端可以根据自己的情况发送数据，接收端会相应地接收数据，如果此时接收端处于高负荷阶段，无法再接收数据了，接收端就会丢弃发送端的数据包。显然，这么做并不是十分合理，因为这样会导致发送端重新发包，重新发包比起一次性接收网络包肯定是有更多传输消耗的。

因此，为了解决这个问题，TCP引入了流量控制机制，发送端可以根据接收端可接收的大小依据当前自己情况来判断是否要继续发送数据。

![image-20210303123932740](https://gitee.com/krialy/images/raw/master/source/20210303123934.png)

#### TCP中的拥塞控制

#### TCP粘包问题

## 参考

[图解HTTP](https://book.douban.com/subject/25863515/)

[图解TCP/IP](https://book.douban.com/subject/24737674/)